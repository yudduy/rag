{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 141, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/db/schema.ts"],"sourcesContent":["import { Message } from \"ai\";\nimport { InferSelectModel } from \"drizzle-orm\";\nimport {\n  pgTable,\n  varchar,\n  timestamp,\n  json,\n  uuid,\n  boolean,\n  text,\n  integer,\n  unique,\n} from \"drizzle-orm/pg-core\";\nimport { sql } from \"drizzle-orm\";\n\nexport const user = pgTable(\"User\", {\n  id: uuid(\"id\").primaryKey().notNull().defaultRandom(),\n  email: varchar(\"email\", { length: 64 }).notNull(),\n  password: varchar(\"password\", { length: 128 }),\n}, (table) => ({\n  uniqueEmail: unique().on(table.email),\n}));\n\nexport type User = InferSelectModel<typeof user>;\n\nexport const chat = pgTable(\"Chat\", {\n  id: uuid(\"id\").primaryKey().notNull().defaultRandom(),\n  createdAt: timestamp(\"createdAt\").notNull(),\n  messages: json(\"messages\").notNull(),\n  userId: uuid(\"userId\")\n    .notNull()\n    .references(() => user.id),\n});\n\nexport type Chat = Omit<InferSelectModel<typeof chat>, \"messages\"> & {\n  messages: Array<Message>;\n};\n\nexport const reservation = pgTable(\"Reservation\", {\n  id: uuid(\"id\").primaryKey().notNull().defaultRandom(),\n  createdAt: timestamp(\"createdAt\").notNull(),\n  details: json(\"details\").notNull(),\n  hasCompletedPayment: boolean(\"hasCompletedPayment\").notNull().default(false),\n  userId: uuid(\"userId\")\n    .notNull()\n    .references(() => user.id),\n});\n\nexport type Reservation = InferSelectModel<typeof reservation>;\n\nexport const document = pgTable(\"Document\", {\n  id: uuid(\"id\").primaryKey().notNull().defaultRandom(),\n  filename: varchar(\"filename\", { length: 255 }).notNull(),\n  originalName: varchar(\"originalName\", { length: 255 }).notNull(),\n  fileType: varchar(\"fileType\", { length: 50 }).notNull(),\n  fileSize: integer(\"fileSize\").notNull(),\n  content: text(\"content\").notNull(),\n  status: varchar(\"status\", { length: 20 }).notNull().default(\"indexed\"), // pending, indexing, indexed, failed\n  chunkCount: integer(\"chunkCount\").notNull().default(0),\n  createdAt: timestamp(\"createdAt\").notNull().default(sql`CURRENT_TIMESTAMP`),\n  updatedAt: timestamp(\"updatedAt\").notNull().default(sql`CURRENT_TIMESTAMP`),\n  userId: uuid(\"userId\")\n    .notNull()\n    .references(() => user.id, { onDelete: \"cascade\" }),\n});\n\nexport type Document = InferSelectModel<typeof document>;\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAeO,MAAM,OAAO,CAAA,GAAA,uJAAA,CAAA,UAAO,AAAD,EAAE,QAAQ;IAClC,IAAI,CAAA,GAAA,iKAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,OAAO,GAAG,aAAa;IACnD,OAAO,CAAA,GAAA,oKAAA,CAAA,UAAO,AAAD,EAAE,SAAS;QAAE,QAAQ;IAAG,GAAG,OAAO;IAC/C,UAAU,CAAA,GAAA,oKAAA,CAAA,UAAO,AAAD,EAAE,YAAY;QAAE,QAAQ;IAAI;AAC9C,GAAG,CAAC,QAAU,CAAC;QACb,aAAa,CAAA,GAAA,sKAAA,CAAA,SAAM,AAAD,IAAI,EAAE,CAAC,MAAM,KAAK;IACtC,CAAC;AAIM,MAAM,OAAO,CAAA,GAAA,uJAAA,CAAA,UAAO,AAAD,EAAE,QAAQ;IAClC,IAAI,CAAA,GAAA,iKAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,OAAO,GAAG,aAAa;IACnD,WAAW,CAAA,GAAA,sKAAA,CAAA,YAAS,AAAD,EAAE,aAAa,OAAO;IACzC,UAAU,CAAA,GAAA,iKAAA,CAAA,OAAI,AAAD,EAAE,YAAY,OAAO;IAClC,QAAQ,CAAA,GAAA,iKAAA,CAAA,OAAI,AAAD,EAAE,UACV,OAAO,GACP,UAAU,CAAC,IAAM,KAAK,EAAE;AAC7B;AAMO,MAAM,cAAc,CAAA,GAAA,uJAAA,CAAA,UAAO,AAAD,EAAE,eAAe;IAChD,IAAI,CAAA,GAAA,iKAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,OAAO,GAAG,aAAa;IACnD,WAAW,CAAA,GAAA,sKAAA,CAAA,YAAS,AAAD,EAAE,aAAa,OAAO;IACzC,SAAS,CAAA,GAAA,iKAAA,CAAA,OAAI,AAAD,EAAE,WAAW,OAAO;IAChC,qBAAqB,CAAA,GAAA,oKAAA,CAAA,UAAO,AAAD,EAAE,uBAAuB,OAAO,GAAG,OAAO,CAAC;IACtE,QAAQ,CAAA,GAAA,iKAAA,CAAA,OAAI,AAAD,EAAE,UACV,OAAO,GACP,UAAU,CAAC,IAAM,KAAK,EAAE;AAC7B;AAIO,MAAM,WAAW,CAAA,GAAA,uJAAA,CAAA,UAAO,AAAD,EAAE,YAAY;IAC1C,IAAI,CAAA,GAAA,iKAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,OAAO,GAAG,aAAa;IACnD,UAAU,CAAA,GAAA,oKAAA,CAAA,UAAO,AAAD,EAAE,YAAY;QAAE,QAAQ;IAAI,GAAG,OAAO;IACtD,cAAc,CAAA,GAAA,oKAAA,CAAA,UAAO,AAAD,EAAE,gBAAgB;QAAE,QAAQ;IAAI,GAAG,OAAO;IAC9D,UAAU,CAAA,GAAA,oKAAA,CAAA,UAAO,AAAD,EAAE,YAAY;QAAE,QAAQ;IAAG,GAAG,OAAO;IACrD,UAAU,CAAA,GAAA,oKAAA,CAAA,UAAO,AAAD,EAAE,YAAY,OAAO;IACrC,SAAS,CAAA,GAAA,iKAAA,CAAA,OAAI,AAAD,EAAE,WAAW,OAAO;IAChC,QAAQ,CAAA,GAAA,oKAAA,CAAA,UAAO,AAAD,EAAE,UAAU;QAAE,QAAQ;IAAG,GAAG,OAAO,GAAG,OAAO,CAAC;IAC5D,YAAY,CAAA,GAAA,oKAAA,CAAA,UAAO,AAAD,EAAE,cAAc,OAAO,GAAG,OAAO,CAAC;IACpD,WAAW,CAAA,GAAA,sKAAA,CAAA,YAAS,AAAD,EAAE,aAAa,OAAO,GAAG,OAAO,CAAC,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC;IAC1E,WAAW,CAAA,GAAA,sKAAA,CAAA,YAAS,AAAD,EAAE,aAAa,OAAO,GAAG,OAAO,CAAC,8IAAA,CAAA,MAAG,CAAC,iBAAiB,CAAC;IAC1E,QAAQ,CAAA,GAAA,iKAAA,CAAA,OAAI,AAAD,EAAE,UACV,OAAO,GACP,UAAU,CAAC,IAAM,KAAK,EAAE,EAAE;QAAE,UAAU;IAAU;AACrD"}},
    {"offset": {"line": 207, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 212, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/db/queries.ts"],"sourcesContent":["import \"server-only\";\n\nimport { genSaltSync, hashSync } from \"bcrypt-ts\";\nimport { desc, eq } from \"drizzle-orm\";\nimport { drizzle } from \"drizzle-orm/postgres-js\";\nimport postgres from \"postgres\";\n\nimport { user, chat, User, reservation, document, Document } from \"./schema\";\n\n// Optionally, if not using email/pass login, you can\n// use the Drizzle adapter for Auth.js / NextAuth\n// https://authjs.dev/reference/adapter/drizzle\n\n// Handle build-time when POSTGRES_URL might not be available\nconst connectionString = process.env.POSTGRES_URL \n  ? (() => {\n      const url = new URL(process.env.POSTGRES_URL);\n      url.searchParams.set('sslmode', 'require');\n      return url.toString();\n    })()\n  : 'postgres://dummy:dummy@localhost:5432/dummy';\n\nlet client = postgres(connectionString, { \n  max: 1,\n  // Prevent connections during build\n  transform: process.env.NODE_ENV === 'production' && !process.env.POSTGRES_URL \n    ? undefined \n    : postgres.camel\n});\nlet db = drizzle(client);\n\nexport async function getUser(email: string): Promise<Array<User>> {\n  try {\n    return await db.select().from(user).where(eq(user.email, email));\n  } catch (error) {\n    console.error(\"Failed to get user from database\");\n    throw error;\n  }\n}\n\nexport async function createUser(email: string, password: string) {\n  let salt = genSaltSync(10);\n  let hash = hashSync(password, salt);\n\n  try {\n    return await db.insert(user).values({ email, password: hash });\n  } catch (error) {\n    console.error(\"Failed to create user in database\");\n    throw error;\n  }\n}\n\nexport async function saveChat({\n  id,\n  messages,\n  userId,\n}: {\n  id: string;\n  messages: any;\n  userId: string;\n}) {\n  try {\n    const selectedChats = await db.select().from(chat).where(eq(chat.id, id));\n\n    if (selectedChats.length > 0) {\n      return await db\n        .update(chat)\n        .set({\n          messages: JSON.stringify(messages),\n        })\n        .where(eq(chat.id, id));\n    }\n\n    return await db.insert(chat).values({\n      id,\n      createdAt: new Date(),\n      messages: JSON.stringify(messages),\n      userId,\n    });\n  } catch (error) {\n    console.error(\"Failed to save chat in database\");\n    throw error;\n  }\n}\n\nexport async function deleteChatById({ id }: { id: string }) {\n  try {\n    return await db.delete(chat).where(eq(chat.id, id));\n  } catch (error) {\n    console.error(\"Failed to delete chat by id from database\");\n    throw error;\n  }\n}\n\nexport async function getChatsByUserId({ id }: { id: string }) {\n  try {\n    return await db\n      .select()\n      .from(chat)\n      .where(eq(chat.userId, id))\n      .orderBy(desc(chat.createdAt));\n  } catch (error) {\n    console.error(\"Failed to get chats by user from database\");\n    throw error;\n  }\n}\n\nexport async function getChatById({ id }: { id: string }) {\n  try {\n    const [selectedChat] = await db.select().from(chat).where(eq(chat.id, id));\n    return selectedChat;\n  } catch (error) {\n    console.error(\"Failed to get chat by id from database\");\n    throw error;\n  }\n}\n\nexport async function createReservation({\n  id,\n  userId,\n  details,\n}: {\n  id: string;\n  userId: string;\n  details: any;\n}) {\n  return await db.insert(reservation).values({\n    id,\n    createdAt: new Date(),\n    userId,\n    hasCompletedPayment: false,\n    details: JSON.stringify(details),\n  });\n}\n\nexport async function getReservationById({ id }: { id: string }) {\n  const [selectedReservation] = await db\n    .select()\n    .from(reservation)\n    .where(eq(reservation.id, id));\n\n  return selectedReservation;\n}\n\nexport async function updateReservation({\n  id,\n  hasCompletedPayment,\n}: {\n  id: string;\n  hasCompletedPayment: boolean;\n}) {\n  return await db\n    .update(reservation)\n    .set({\n      hasCompletedPayment,\n    })\n    .where(eq(reservation.id, id));\n}\n\n// Document queries\nexport async function createDocument({\n  filename,\n  originalName,\n  fileType,\n  fileSize,\n  content,\n  userId,\n}: {\n  filename: string;\n  originalName: string;\n  fileType: string;\n  fileSize: number;\n  content: string;\n  userId: string;\n}): Promise<Document> {\n  try {\n    const [newDocument] = await db\n      .insert(document)\n      .values({\n        filename,\n        originalName,\n        fileType,\n        fileSize,\n        content,\n        userId,\n        status: \"indexed\",\n        chunkCount: 0,\n      })\n      .returning();\n    \n    return newDocument;\n  } catch (error) {\n    console.error(\"Failed to create document in database\");\n    throw error;\n  }\n}\n\nexport async function getDocumentsByUserId({ userId }: { userId: string }): Promise<Document[]> {\n  try {\n    return await db\n      .select()\n      .from(document)\n      .where(eq(document.userId, userId))\n      .orderBy(desc(document.createdAt));\n  } catch (error) {\n    console.error(\"Failed to get documents by user from database\");\n    throw error;\n  }\n}\n\nexport async function getDocumentById({ id }: { id: string }): Promise<Document | undefined> {\n  try {\n    const [selectedDocument] = await db\n      .select()\n      .from(document)\n      .where(eq(document.id, id));\n    return selectedDocument;\n  } catch (error) {\n    console.error(\"Failed to get document by id from database\");\n    throw error;\n  }\n}\n\nexport async function updateDocumentChunkCount({\n  id,\n  chunkCount,\n}: {\n  id: string;\n  chunkCount: number;\n}) {\n  try {\n    return await db\n      .update(document)\n      .set({\n        chunkCount,\n        updatedAt: new Date(),\n      })\n      .where(eq(document.id, id));\n  } catch (error) {\n    console.error(\"Failed to update document chunk count\");\n    throw error;\n  }\n}\n\nexport async function deleteDocumentById({ id }: { id: string }) {\n  try {\n    return await db.delete(document).where(eq(document.id, id));\n  } catch (error) {\n    console.error(\"Failed to delete document by id from database\");\n    throw error;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 394, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 399, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/app/(auth)/auth.config.ts"],"sourcesContent":["import { NextAuthConfig } from \"next-auth\";\n\nexport const authConfig = {\n  pages: {\n    signIn: \"/login\",\n    newUser: \"/\",\n  },\n  providers: [\n    // added later in auth.ts since it requires bcrypt which is only compatible with Node.js\n    // while this file is also used in non-Node.js environments\n  ],\n  callbacks: {\n    authorized({ auth, request: { nextUrl } }) {\n      let isLoggedIn = !!auth?.user;\n      let isOnChat = nextUrl.pathname.startsWith(\"/\");\n      let isOnRegister = nextUrl.pathname.startsWith(\"/register\");\n      let isOnLogin = nextUrl.pathname.startsWith(\"/login\");\n\n      if (isLoggedIn && (isOnLogin || isOnRegister)) {\n        return Response.redirect(new URL(\"/\", nextUrl));\n      }\n\n      if (isOnRegister || isOnLogin) {\n        return true; // Always allow access to register and login pages\n      }\n\n      if (isOnChat) {\n        if (isLoggedIn) return true;\n        return false; // Redirect unauthenticated users to login page\n      }\n\n      if (isLoggedIn) {\n        return Response.redirect(new URL(\"/\", nextUrl));\n      }\n\n      return true;\n    },\n  },\n} satisfies NextAuthConfig;\n"],"names":[],"mappings":";;;AAEO,MAAM,aAAa;IACxB,OAAO;QACL,QAAQ;QACR,SAAS;IACX;IACA,WAAW,EAGV;IACD,WAAW;QACT,YAAW,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE,EAAE;YACvC,IAAI,aAAa,CAAC,CAAC,MAAM;YACzB,IAAI,WAAW,QAAQ,QAAQ,CAAC,UAAU,CAAC;YAC3C,IAAI,eAAe,QAAQ,QAAQ,CAAC,UAAU,CAAC;YAC/C,IAAI,YAAY,QAAQ,QAAQ,CAAC,UAAU,CAAC;YAE5C,IAAI,cAAc,CAAC,aAAa,YAAY,GAAG;gBAC7C,OAAO,SAAS,QAAQ,CAAC,IAAI,IAAI,KAAK;YACxC;YAEA,IAAI,gBAAgB,WAAW;gBAC7B,OAAO,MAAM,kDAAkD;YACjE;YAEA,IAAI,UAAU;gBACZ,IAAI,YAAY,OAAO;gBACvB,OAAO,OAAO,+CAA+C;YAC/D;YAEA,IAAI,YAAY;gBACd,OAAO,SAAS,QAAQ,CAAC,IAAI,IAAI,KAAK;YACxC;YAEA,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 431, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 436, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/app/(auth)/auth.ts"],"sourcesContent":["import { compare } from \"bcrypt-ts\";\nimport NextAuth, { User, Session } from \"next-auth\";\nimport Credentials from \"next-auth/providers/credentials\";\n\nimport { getUser } from \"@/db/queries\";\n\nimport { authConfig } from \"./auth.config\";\n\ninterface ExtendedSession extends Session {\n  user: User;\n}\n\nexport const {\n  handlers: { GET, POST },\n  auth,\n  signIn,\n  signOut,\n} = NextAuth({\n  ...authConfig,\n  providers: [\n    Credentials({\n      credentials: {},\n      async authorize({ email, password }: any) {\n        if (!email || !password) return null;\n        \n        let users = await getUser(email);\n        if (users.length === 0) return null;\n        \n        const user = users[0];\n        if (!user.password) return null;\n        \n        let passwordsMatch = await compare(password, user.password);\n        if (passwordsMatch) return user;\n        \n        return null;\n      },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n      }\n\n      return token;\n    },\n    async session({\n      session,\n      token,\n    }: {\n      session: ExtendedSession;\n      token: any;\n    }) {\n      if (session.user) {\n        session.user.id = token.id as string;\n      }\n\n      return session;\n    },\n  },\n});\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAYO,MAAM,EACX,UAAU,EAAE,GAAG,EAAE,IAAI,EAAE,EACvB,IAAI,EACJ,MAAM,EACN,OAAO,EACR,GAAG,CAAA,GAAA,uJAAA,CAAA,UAAQ,AAAD,EAAE;IACX,GAAG,mIAAA,CAAA,aAAU;IACb,WAAW;QACT,CAAA,GAAA,4JAAA,CAAA,UAAW,AAAD,EAAE;YACV,aAAa,CAAC;YACd,MAAM,WAAU,EAAE,KAAK,EAAE,QAAQ,EAAO;gBACtC,IAAI,CAAC,SAAS,CAAC,UAAU,OAAO;gBAEhC,IAAI,QAAQ,MAAM,CAAA,GAAA,+GAAA,CAAA,UAAO,AAAD,EAAE;gBAC1B,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO;gBAE/B,MAAM,OAAO,KAAK,CAAC,EAAE;gBACrB,IAAI,CAAC,KAAK,QAAQ,EAAE,OAAO;gBAE3B,IAAI,iBAAiB,MAAM,CAAA,GAAA,+IAAA,CAAA,UAAO,AAAD,EAAE,UAAU,KAAK,QAAQ;gBAC1D,IAAI,gBAAgB,OAAO;gBAE3B,OAAO;YACT;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;YACpB;YAEA,OAAO;QACT;QACA,MAAM,SAAQ,EACZ,OAAO,EACP,KAAK,EAIN;YACC,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;YAC5B;YAEA,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 488, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 619, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/app/(chat)/api/files/upload/route.ts"],"sourcesContent":["import { put } from \"@vercel/blob\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\nimport { randomUUID } from \"crypto\";\nimport path from \"path\";\n\nimport { auth } from \"@/app/(auth)/auth\";\n\nconst FileSchema = z.object({\n  file: z\n    .instanceof(File)\n    .refine((file) => file.size <= 5 * 1024 * 1024, {\n      message: \"File size should be less than 5MB\",\n    })\n    .refine(\n      (file) =>\n        [\"image/jpeg\", \"image/png\", \"application/pdf\"].includes(file.type),\n      {\n        message: \"File type should be JPEG, PNG, or PDF\",\n      },\n    ),\n});\n\nfunction sanitizeFilename(originalFilename: string): string {\n  // Get the file extension safely\n  const ext = path.extname(originalFilename).toLowerCase();\n  const allowedExtensions = ['.jpg', '.jpeg', '.png', '.pdf'];\n  \n  // Use a safe extension or default to empty string\n  const safeExtension = allowedExtensions.includes(ext) ? ext : '';\n  \n  // Generate a unique filename with UUID\n  const uniqueId = randomUUID();\n  \n  return `${uniqueId}${safeExtension}`;\n}\n\nexport async function POST(request: Request) {\n  const session = await auth();\n\n  if (!session) {\n    return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n  }\n\n  if (request.body === null) {\n    return new Response(\"Request body is empty\", { status: 400 });\n  }\n\n  try {\n    const formData = await request.formData();\n    const file = formData.get(\"file\") as File;\n\n    if (!file) {\n      return NextResponse.json({ error: \"No file uploaded\" }, { status: 400 });\n    }\n\n    const validatedFile = FileSchema.safeParse({ file });\n\n    if (!validatedFile.success) {\n      const errorMessage = validatedFile.error.errors\n        .map((error) => error.message)\n        .join(\", \");\n\n      return NextResponse.json({ error: errorMessage }, { status: 400 });\n    }\n\n    const originalFilename = file.name;\n    const sanitizedFilename = sanitizeFilename(originalFilename);\n    const fileBuffer = await file.arrayBuffer();\n\n    try {\n      const data = await put(sanitizedFilename, fileBuffer, {\n        access: \"public\",\n      });\n\n      return NextResponse.json(data);\n    } catch (error) {\n      return NextResponse.json({ error: \"Upload failed\" }, { status: 500 });\n    }\n  } catch (error) {\n    return NextResponse.json(\n      { error: \"Failed to process request\" },\n      { status: 500 },\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAQA,MAAM,aAAa,oKAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC1B,MAAM,oKAAA,CAAA,IAAC,CACJ,UAAU,CAAC,MACX,MAAM,CAAC,CAAC,OAAS,KAAK,IAAI,IAAI,IAAI,OAAO,MAAM;QAC9C,SAAS;IACX,GACC,MAAM,CACL,CAAC,OACC;YAAC;YAAc;YAAa;SAAkB,CAAC,QAAQ,CAAC,KAAK,IAAI,GACnE;QACE,SAAS;IACX;AAEN;AAEA,SAAS,iBAAiB,gBAAwB;IAChD,gCAAgC;IAChC,MAAM,MAAM,6FAAA,CAAA,UAAI,CAAC,OAAO,CAAC,kBAAkB,WAAW;IACtD,MAAM,oBAAoB;QAAC;QAAQ;QAAS;QAAQ;KAAO;IAE3D,kDAAkD;IAClD,MAAM,gBAAgB,kBAAkB,QAAQ,CAAC,OAAO,MAAM;IAE9D,uCAAuC;IACvC,MAAM,WAAW,CAAA,GAAA,+FAAA,CAAA,aAAU,AAAD;IAE1B,OAAO,CAAC,EAAE,SAAS,EAAE,cAAc,CAAC;AACtC;AAEO,eAAe,KAAK,OAAgB;IACzC,MAAM,UAAU,MAAM,CAAA,GAAA,yHAAA,CAAA,OAAI,AAAD;IAEzB,IAAI,CAAC,SAAS;QACZ,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAe,GAAG;YAAE,QAAQ;QAAI;IACpE;IAEA,IAAI,QAAQ,IAAI,KAAK,MAAM;QACzB,OAAO,IAAI,SAAS,yBAAyB;YAAE,QAAQ;QAAI;IAC7D;IAEA,IAAI;QACF,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,OAAO,SAAS,GAAG,CAAC;QAE1B,IAAI,CAAC,MAAM;YACT,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAmB,GAAG;gBAAE,QAAQ;YAAI;QACxE;QAEA,MAAM,gBAAgB,WAAW,SAAS,CAAC;YAAE;QAAK;QAElD,IAAI,CAAC,cAAc,OAAO,EAAE;YAC1B,MAAM,eAAe,cAAc,KAAK,CAAC,MAAM,CAC5C,GAAG,CAAC,CAAC,QAAU,MAAM,OAAO,EAC5B,IAAI,CAAC;YAER,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAa,GAAG;gBAAE,QAAQ;YAAI;QAClE;QAEA,MAAM,mBAAmB,KAAK,IAAI;QAClC,MAAM,oBAAoB,iBAAiB;QAC3C,MAAM,aAAa,MAAM,KAAK,WAAW;QAEzC,IAAI;YACF,MAAM,OAAO,MAAM,CAAA,GAAA,mKAAA,CAAA,MAAG,AAAD,EAAE,mBAAmB,YAAY;gBACpD,QAAQ;YACV;YAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;QAC3B,EAAE,OAAO,OAAO;YACd,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAgB,GAAG;gBAAE,QAAQ;YAAI;QACrE;IACF,EAAE,OAAO,OAAO;QACd,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA4B,GACrC;YAAE,QAAQ;QAAI;IAElB;AACF"}},
    {"offset": {"line": 719, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}